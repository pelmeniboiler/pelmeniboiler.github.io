<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graflect Transliteration Tool</title>
    <link rel="stylesheet" href="pelmeni2025.css">
    <style>
        :root {
            --bg-color: #1e1e1e;
            --text-color: #dcdcdc;
            --primary-color: #569cd6;
            --input-bg: #252526;
            --border-color: #3e3e42;
            --button-bg: #0e639c;
            --button-hover-bg: #1177bb;
            --prompt-bg: #2d2d30;
            --success-bg: #2a9d8f;
            --error-bg: #e76f51;
            --danger-bg: #c94c4c;
            --danger-hover-bg: #e15757;
            --warning-bg: #f4a261;
            --warning-hover-bg: #e76f51;
            --info-bg: #e9c46a;
            --info-hover-bg: #d8b359;
        }
        body {
            font-family: "Fairfax HD", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 2em;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            width: 100%;
            max-width: 800px;
            display: flex;
            flex-direction: column;
            gap: 1.5em;
        }
        h1, h2 {
            color: var(--primary-color);
            text-align: center;
            margin: 0;
        }
        h1 {
            font-size: 2.5em;
            font-family: 'Fairfax HD';
        }
        .active-dict-display {
            text-align: center;
            font-style: italic;
            color: var(--info-bg);
        }
        .textarea-container {
            position: relative;
            width: 100%;
        }
        textarea, #output-container, #prompt-area {
            width: 100%;
            box-sizing: border-box;
            padding: 1em;
            border-radius: 5px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1.2em;
            line-height: 1.6;
            font-family: 'Fairfax HD';
        }
        textarea {
            min-height: 150px;
            resize: vertical;
            padding-right: 150px; /* Make space for the button */
        }
        #output-container {
            min-height: 100px;
            background-color: #1a1a1a;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        #output {
            font-family: 'Fairfax HD';
            font-size: 1.5em;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1em;
            justify-content: center;
            font-family: 'Fairfax HD';
        }
        button, .button-label {
            padding: 0.8em 1.5em;
            font-size: 1em;
            font-family: 'Fairfax HD';
            font-weight: bold;
            color: white;
            background-color: var(--button-bg);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            text-align: center;
        }
        button:hover:not(:disabled), .button-label:hover {
            background-color: var(--button-hover-bg);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #manage-dict-btn {
            background-color: var(--warning-bg);
        }
        #manage-dict-btn:hover {
            background-color: var(--warning-hover-bg);
        }
        #diagnostic-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 0.4em 0.8em;
            font-size: 0.9em;
            background-color: var(--info-bg);
            color: #1e1e1e;
            font-weight: bold;
        }
        #diagnostic-btn:hover {
            background-color: var(--info-hover-bg);
        }
        #prompt-area {
            margin-top: 1em;
            background-color: var(--prompt-bg);
            border-left: 5px solid var(--primary-color);
        }
        .prompt-word-highlight {
            font-style: italic;
            color: var(--primary-color);
            font-weight: bold;
        }
        .choice-buttons button {
            margin-right: 0.5em;
            margin-bottom: 0.5em;
            background-color: #3e3e42;
        }
        .choice-buttons button:hover {
            background-color: #5a5a5e;
        }
        .remember-choice {
            margin-top: 1.5em;
            display: flex;
            align-items: center;
        }
        .remember-choice input {
            margin-right: 0.5em;
            width: 18px;
            height: 18px;
        }
        #direct-input-area {
            margin-top: 1.5em;
            padding-top: 1em;
            border-top: 1px solid var(--border-color);
        }
        #direct-graflect-input {
            flex-grow: 1;
            font-family: 'Fairfax HD';
            font-size: 1.2em;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 0.5em;
            border-radius: 3px;
        }
        #use-direct-input-btn {
            padding: 0.5em 1em;
            font-size: 1em;
        }
        #notification {
            position: fixed;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1em 2em;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            text-align: center;
            z-index: 1000;
            transition: top 0.5s ease-in-out;
        }
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background-color: var(--bg-color);
            padding: 2em;
            border: 1px solid var(--border-color);
            width: 90%;
            max-width: 700px;
            border-radius: 8px;
            color: var(--text-color);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 1em;
            margin-bottom: 1em;
        }
        .close-button {
            color: var(--text-color);
            font-size: 2em;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover {
            color: var(--primary-color);
        }
        .modal-list {
            list-style: none;
            padding: 0;
            max-height: 50vh;
            overflow-y: auto;
        }
        .modal-list li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.8em;
            border-bottom: 1px solid var(--border-color);
        }
        .modal-list li:last-child {
            border-bottom: none;
        }
        .dict-info .name { font-weight: bold; color: var(--primary-color); }
        .dict-info .author { font-style: italic; font-size: 0.9em; }
        .dict-info .description { font-size: 0.9em; margin-top: 0.5em; }
        .dict-edit-input {
            background-color: var(--input-bg);
            border: 1px solid var(--primary-color);
            color: var(--text-color);
            font-family: 'Fairfax HD';
            font-size: 1.2em;
            padding: 0.2em;
            border-radius: 3px;
            flex-grow: 1;
            margin-left: 1em;
        }
        .dict-btn {
             background-color: var(--button-bg);
            color: white;
            border: none;
            padding: 0.4em 0.8em;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 0.5em;
        }
        .dict-btn.remove, .dict-btn.delete {
            background-color: var(--danger-bg);
        }
        .dict-btn.remove:hover, .dict-btn.delete:hover {
            background-color: var(--danger-hover-bg);
        }
        .dict-btn.save, .dict-btn.select {
            background-color: var(--success-bg);
        }
        .modal-footer {
            margin-top: 1.5em;
            padding-top: 1.5em;
            border-top: 1px solid var(--border-color);
            display: flex;
            gap: 1em;
            justify-content: flex-end;
        }
        .modal-form-group {
            margin-bottom: 1em;
        }
        .modal-form-group label {
            display: block;
            margin-bottom: 0.5em;
        }
        .modal-form-group input, .modal-form-group textarea {
            width: 100%;
            box-sizing: border-box;
            padding: 0.5em;
            border-radius: 3px;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
        }
    </style>
</head>
<body>
    <div id="notification"></div>

    <div class="container">
        <h1></h1>
        <h2>Graflect Transliteration Tool</h2>
        <div class="active-dict-display">
            Active Dictionary: <span id="active-dict-name"></span>
        </div>
        <div class="textarea-container">
            <textarea id="english-input" placeholder="Enter English text here, or try the diagnostic paragraph..."></textarea>
            <button id="diagnostic-btn">Insert Diagnostic</button>
        </div>
        <div class="controls">
            <button id="transliterate-btn">Transliterate</button>
            <button id="manage-dict-btn">Manage Dictionaries</button>
        </div>
        <div id="prompt-area" style="display: none;">
            <h3 id="prompt-heading"></h3>
            <p id="prompt-instruction"></p>
            <div id="prompt-buttons-container" class="choice-buttons"></div>
            
            <div id="direct-input-area">
                <label for="direct-graflect-input">Or enter direct Graflect substitution:</label>
                <div style="display: flex; gap: 0.5em; margin-top: 0.5em;">
                    <input type="text" id="direct-graflect-input">
                    <button id="use-direct-input-btn">Use</button>
                </div>
            </div>

            <div class="remember-choice">
                <input type="checkbox" id="remember-choice-checkbox" checked>
                <label for="remember-choice-checkbox">Remember this choice for the word "<span id="prompt-word-for-checkbox"></span>"</label>
            </div>
        </div>
        <h2>Result:</h2>
        <div id="output-container">
            <span id="output"></span>
        </div>
    </div>

    <!-- Modals -->
    <div id="dictionary-manager-modal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Manage Dictionaries</h2>
                <span class="close-button" id="close-manager-btn">&times;</span>
            </div>
            <ul id="dictionary-list" class="modal-list"></ul>
            <div class="modal-footer">
                <button id="new-dict-btn" class="dict-btn save">New Empty Dictionary</button>
                <label for="import-input" class="button-label">Import Dictionary</label>
                <input type="file" id="import-input" accept=".json" style="display: none;">
            </div>
        </div>
    </div>

    <div id="word-editor-modal" class="modal-overlay">
         <div class="modal-content">
            <div class="modal-header">
                <h2 id="word-editor-title">Edit Dictionary</h2>
                <span class="close-button" id="close-editor-btn">&times;</span>
            </div>
            <ul id="word-list" class="modal-list"></ul>
        </div>
    </div>

    <script>
        // --- DATA MAPPINGS ---
        const graflectMap = {
            '/p/': '', '/b/': '', '/t/': '', '/d/': '', '/k/': '', '/ɡ/': '',
            '/f/': '', '/v/': '', '/θ/': '', '/ð/': '', '/s/': '', '/z/': '',
            '/ʃ/': '', '/ʒ/': '', '/h/': '', '/m/': '', '/n/': '', '/ŋ/': '',
            '/l/': '', '/r/': '', '/w/': '', '/j/': '', '/iː/': '', '/ɪ/': '',
            '/ʊ/': '', '/u/': '', '/ɛ/': '', '/æ/': '', '/ʌ/': '', '/ə/': '',
            '/ɑ/': '', '/eɪ/': '', '/ɛə/': '', '/aɪ/': '', '/aʊ/': '', '/oʊ/': '',
            '/ɔ/': '', '/ɜː/': '', '/ɛər/': '', '/tʃ/': '', '/dʒ/': '', '/ju/': '',
            '/wi/': '', '/ɥi/': '', '/x/': '', '/ɾ/': '', '/ʁ/': '',
            '/ks/': '', '/kw/': '', '/ɒ/': '', '/uː/': '',
            '/ɔɪ/': '', '/ʃən/': '', '/ʒən/': '', '/ʃəs/': '',
            '/ʃəl/': '', '/ʒər/': '', '/ʃʊər/': '', '/tʃər/': '',
            '/sk/': '', '/səl/': '', '/ɛks/': '',
            '/ɛɡz/': '', '/ɡw/': '', '/juː/': '', '/ndʒ/': ''
        };

        const defaultWordMap = {
            'a': '', 'an': '',
            'are': '', 'as': '', 'at': '', 'be': '', 'because': '',
            'been': '', 'before': '', 'but': '', 'by': '',
            'change': '', 'come': '', 'could': '', 'day': '', 'do': '',
            'each': '', 'even': '', 'first': '', 'for': '',
            'from': '', 'get': '', 'give': '',
            'great': '', 'had': '', 'has': '', 'have': '', 'he': '',
            'her': '', 'here': '', 'him': '', 'his': '',
            'i': '', 'if': '', 'in': '', 'into': '', 'is': '', 'it': '',
            'its': '', 'just': '', 'like': '',
            'made': '', 'make': '',
            'me': '', 'more': '', 'most': '', 'my': '', 'new': '',
            'of': '', 'on': '',
            'one': '', 'only': '', 'or': '', 'other': '',
            'over': '', 'people': '', 'place': '',
            'said': '', 'same': '', 'see': '', 'she': '',
            'some': '', 'take': '', 'than': '', 'that': '', 'the': '',
            'their': '', 'them': '', 'then': '', 'there': '', 'these': '',
            'they': '', 'thing': '', 'think': '', 'this': '', 'those': '',
            'time': '', 'to': '', 'two': '', 'up': '', 'use': '',
            'very': '', 'want': '', 'was': '',
            'way': '', 'we': '', 'well': '', 'were': '',
            'when': '', 'where': '', 'which': '', 'who': '', 'why': '',
            'will': '', 'with': '', 'work': '', 'would': '', 'year': '',
            'you': '', 'your': ''
        };

        const graphemeToIpa = {
            'tious': '/ʃəs/', 'cious': '/ʃəs/', 'ssion': '/ʃən/', 'stle': '/səl/',
            'sion': ['/ʃən/', '/ʒən/'], 'tion': '/ʃən/', 'cian': '/ʃən/',
            'tial': '/ʃəl/', 'cial': '/ʃəl/', 'sure': ['/ʒər/', '/ʃʊər/'],
            'ture': '/tʃər/', 'dge': '/dʒ/', 'eigh': '/eɪ/', 'igh': '/aɪ/',
            'tch': '/tʃ/', 'age': ['/ɪdʒ/', '/eɪdʒ/'], 'ex': ['/ɛks/', '/ɛɡz/'],
            'nge': '/ndʒ/', 'que': '/k/', 'lk': '/k/', 'lm': '/m/', 'mb': '/m/', 'bt': '/t/',
            'ps': '/s/', 'pn': '/n/', 'rh': '/r/',
            'sch': ['/sk/', '/ʃ/'], 'eau': ['/oʊ/', '/juː/'],
            'sc': ['/sk/', '/s/'], 'gu': ['/ɡ/', '/ɡw/'],
            'ck': '/k/', 'qu': '/kw/', 'th': ['/θ/', '/ð/'], 'sh': '/ʃ/',
            'ch': ['/tʃ/', '/k/', '/ʃ/'], 'ng': '/ŋ/', 'ph': '/f/', 'kn': '/n/', 'wr': '/r/',
            'gh': ['/ɡ/', '/f/', ''], 'oo': ['/uː/', '/ʊ/', '/ʌ/'], 'ee': ['/iː/', '/ɪ/'],
            'ea': ['/iː/', '/ɛ/', '/eɪ/'], 'ou': ['/aʊ/', '/oʊ/', '/u/', '/ʌ/'],
            'ow': ['/aʊ/', '/oʊ/', '/u/'], 'ew': ['/ju/', '/uː/'],
            'au': '/ɔ/', 'oi': '/ɔɪ/', 'oy': '/ɔɪ/',
            'ai': ['/eɪ/', '/ɛ/'], 'ay': '/eɪ/',
            'll': '/l/', 'ss': '/s/', 'ff': '/f/', 'rr': '/r/', 'pp': '/p/', 'bb': '/b/', 
            'dd': '/d/', 'tt': '/t/', 'mm': '/m/', 'nn': '/n/',
            'a': ['/æ/', '/eɪ/', '/ɑ/', '/ə/', '/ɔ/', '/ɛə/'], 'e': ['/ɛ/', '/iː/', '/ə/', '/ɪ/', '/ɛə/'],
            'i': ['/ɪ/', '/aɪ/', '/iː/'], 'o': ['/ɒ/', '/oʊ/', '/ʌ/', '/u/', '/ɔ/'], 
            'u': ['/ʌ/', '/u/', '/ʊ/', '/ju/'], 'y': ['/ɪ/', '/aɪ/', '/iː/'],
            's': ['/s/', '/z/'], 'g': ['/ɡ/', '/dʒ/'], 'c': ['/k/', '/s/'], 'x': ['/ks/', '/z/'],
            'p': '/p/', 'b': '/b/', 't': '/t/', 'd': '/d/', 'k': '/k/', 'f': '/f/',
            'v': '/v/', 'z': '/z/', 'h': '/h/', 'm': '/m/', 'n': '/n/', 'l': '/l/',
            'r': '/r/', 'w': '/w/', 'j': '/dʒ/'
        };
        
        const diagnosticParagraph = "I know that he and she will not go, but we can see what they do. So, all people have a time to find their own way. If you look for it, you may also get more than you think. This one man had a good day; his work was about to make a change. These other people came out from the house to use the long road and go down to the water. How did he know? It was the first time they had been over there. I will give him a call now.";

        // --- DOM ELEMENTS ---
        const inputEl = document.getElementById('english-input');
        const outputEl = document.getElementById('output');
        const transliterateBtn = document.getElementById('transliterate-btn');
        const diagnosticBtn = document.getElementById('diagnostic-btn');
        const manageDictBtn = document.getElementById('manage-dict-btn');
        const activeDictNameEl = document.getElementById('active-dict-name');
        
        // Modals
        const dictionaryManagerModal = document.getElementById('dictionary-manager-modal');
        const wordEditorModal = document.getElementById('word-editor-modal');
        const closeModalManagerBtn = document.getElementById('close-manager-btn');
        const closeWordEditorBtn = document.getElementById('close-editor-btn');
        const dictionaryListEl = document.getElementById('dictionary-list');
        const wordListEl = document.getElementById('word-list');
        const wordEditorTitleEl = document.getElementById('word-editor-title');
        const newDictBtn = document.getElementById('new-dict-btn');
        const importInput = document.getElementById('import-input');

        const notificationEl = document.getElementById('notification');
        const promptAreaEl = document.getElementById('prompt-area');
        const promptHeadingEl = document.getElementById('prompt-heading');
        const promptInstructionEl = document.getElementById('prompt-instruction');
        const promptButtonsEl = document.getElementById('prompt-buttons-container');
        const rememberCheckbox = document.getElementById('remember-choice-checkbox');
        const promptWordCheckboxEl = document.getElementById('prompt-word-for-checkbox');
        const directGraflectInput = document.getElementById('direct-graflect-input');
        const useDirectInputBtn = document.getElementById('use-direct-input-btn');

        // --- STATE ---
        let dictionaries = [];
        let activeDictionaryIndex = 0;
        let currentResolve;
        const graphemeKeys = Object.keys(graphemeToIpa).sort((a, b) => b.length - a.length);
        const ipaKeys = Object.keys(graflectMap).sort((a, b) => b.length - a.length);

        // --- FUNCTIONS ---

        function showNotification(message, isError = false) {
            notificationEl.textContent = message;
            notificationEl.style.backgroundColor = isError ? 'var(--error-bg)' : 'var(--success-bg)';
            notificationEl.style.top = '20px';
            setTimeout(() => {
                notificationEl.style.top = '-100px';
            }, 3000);
        }

        function getActiveDictionary() {
            return dictionaries[activeDictionaryIndex];
        }

        function loadDictionaries() {
            const storedDicts = localStorage.getItem('graflectDictionaries');
            const storedIndex = localStorage.getItem('graflectActiveDictIndex');

            if (storedDicts) {
                dictionaries = JSON.parse(storedDicts);
                activeDictionaryIndex = storedIndex ? parseInt(storedIndex, 10) : 0;
            } else {
                // First time load: create default dictionary
                dictionaries = [{
                    name: "Default",
                    author: "System",
                    description: "Default dictionary with common English words.",
                    words: { ...defaultWordMap }
                }];
                activeDictionaryIndex = 0;
            }
            updateActiveDictDisplay();
            saveAllDictionaries();
        }

        function saveAllDictionaries() {
            localStorage.setItem('graflectDictionaries', JSON.stringify(dictionaries));
            localStorage.setItem('graflectActiveDictIndex', activeDictionaryIndex);
        }
        
        function updateActiveDictDisplay() {
            const activeDict = getActiveDictionary();
            if (activeDict) {
                activeDictNameEl.textContent = activeDict.name;
            }
        }

        function ipaToGraflect(ipaString) {
            if (!ipaString) return '';
            let result = '';
            let remainingIpa = ipaString;
            while (remainingIpa.length > 0) {
                let foundMatch = false;
                for (const key of ipaKeys) {
                    if (remainingIpa.startsWith(key)) {
                        result += graflectMap[key];
                        remainingIpa = remainingIpa.substring(key.length);
                        foundMatch = true;
                        break;
                    }
                }
                if (!foundMatch) {
                    result += remainingIpa[0];
                    remainingIpa = remainingIpa.substring(1);
                }
            }
            return result;
        }

        function findLongestGrapheme(text) {
            for (const key of graphemeKeys) {
                if (text.startsWith(key)) return key;
            }
            return text[0];
        }

        async function promptForChoice(word, grapheme, options, index) {
            transliterateBtn.disabled = true;
            const highlightedWord = `${word.substring(0, index)}<span class="prompt-word-highlight">${word.substring(index, index + grapheme.length)}</span>${word.substring(index + grapheme.length)}`;
            promptHeadingEl.innerHTML = `Ambiguity in "${word}"`;
            promptInstructionEl.innerHTML = `Choose the sound for the highlighted part: ${highlightedWord}`;
            promptWordCheckboxEl.textContent = word;
            promptButtonsEl.innerHTML = '';
            directGraflectInput.value = '';

            const allOptions = [...options, '']; 

            allOptions.forEach(ipa => {
                if (ipa === undefined) return;
                const button = document.createElement('button');
                const graflectChars = ipaToGraflect(ipa);
                button.innerHTML = ipa ? `${ipa} → ${graflectChars}` : 'Silent → (nothing)';
                button.onclick = () => {
                    if (currentResolve) {
                        currentResolve({ type: 'ipa', value: ipa });
                        currentResolve = null;
                    }
                    promptAreaEl.style.display = 'none';
                    transliterateBtn.disabled = false;
                };
                promptButtonsEl.appendChild(button);
            });

            useDirectInputBtn.onclick = () => {
                 if (currentResolve) {
                    currentResolve({ type: 'direct', value: directGraflectInput.value });
                    currentResolve = null;
                }
                promptAreaEl.style.display = 'none';
                transliterateBtn.disabled = false;
            };

            promptAreaEl.style.display = 'block';
            return new Promise(resolve => {
                currentResolve = resolve;
            });
        }

        async function processWord(word) {
            const lowerWord = word.toLowerCase();
            const activeDict = getActiveDictionary();

            if (activeDict.words[lowerWord]) {
                return activeDict.words[lowerWord];
            }
            
            let finalGraflect = '';
            let remaining = lowerWord;
            let originalIndex = 0;

            while (remaining.length > 0) {
                const grapheme = findLongestGrapheme(remaining);
                const ipaOptions = graphemeToIpa[grapheme];

                if (typeof ipaOptions === 'string') {
                    finalGraflect += ipaToGraflect(ipaOptions);
                } else if (Array.isArray(ipaOptions)) {
                    const choice = await promptForChoice(word, grapheme, ipaOptions, originalIndex);
                    let segmentGraflect = '';
                    if (choice.type === 'ipa') {
                        segmentGraflect = ipaToGraflect(choice.value);
                    } else { 
                        segmentGraflect = choice.value;
                    }
                    finalGraflect += segmentGraflect;
                } else {
                    finalGraflect += grapheme;
                }
                remaining = remaining.substring(grapheme.length);
                originalIndex += grapheme.length;
            }

            if (rememberCheckbox.checked && promptAreaEl.style.display === 'none') {
                activeDict.words[lowerWord] = finalGraflect;
                saveAllDictionaries();
            }
            return finalGraflect;
        }

        async function handleTransliterateClick() {
            transliterateBtn.disabled = true;
            transliterateBtn.textContent = "Processing...";
            outputEl.textContent = '';
            const text = inputEl.value;
            const parts = text.split(/(\s+|[.,!?;:"()'-])/g);
            let finalOutput = '';

            for (const part of parts) {
                if (!part) continue;
                if (part.match(/(\s+|[.,!?;:"()'-]|\d+)/)) {
                    finalOutput += part;
                } else {
                    const word = part;
                    const graflectWord = await processWord(word);
                    finalOutput += graflectWord;
                }
                outputEl.textContent = finalOutput;
            }
            
            transliterateBtn.disabled = false;
            transliterateBtn.textContent = "Transliterate";
        }

        function handleExportClick(dictIndex) {
            const dictionary = dictionaries[dictIndex];
            const dictionaryString = JSON.stringify(dictionary, null, 2);
            const blob = new Blob([dictionaryString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${dictionary.name.replace(/\s+/g, '_')}_graflect.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification(`Dictionary "${dictionary.name}" exported!`);
        }

        function handleImportChange(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedDict = JSON.parse(e.target.result);
                    if (typeof importedDict !== 'object' || !importedDict.name || !importedDict.words) {
                        throw new Error("Invalid format. File must be a valid dictionary object.");
                    }
                    dictionaries.push(importedDict);
                    saveAllDictionaries();
                    populateDictionaryManager();
                    showNotification(`Dictionary "${importedDict.name}" imported successfully!`);
                } catch (error) {
                    showNotification("Error: Could not import file. " + error.message, true);
                } finally {
                    importInput.value = '';
                }
            };
            reader.readAsText(file);
        }
        
        function handleDiagnosticClick() {
            inputEl.value = diagnosticParagraph;
            showNotification("Diagnostic paragraph inserted.");
        }

        function openDictionaryManager() {
            populateDictionaryManager();
            dictionaryManagerModal.style.display = 'flex';
        }

        function populateDictionaryManager() {
            dictionaryListEl.innerHTML = '';
            dictionaries.forEach((dict, index) => {
                const li = document.createElement('li');
                const infoDiv = document.createElement('div');
                infoDiv.className = 'dict-info';
                
                const nameSpan = document.createElement('span');
                nameSpan.className = 'name';
                nameSpan.textContent = dict.name + (index === activeDictionaryIndex ? ' (Active)' : '');

                const authorSpan = document.createElement('span');
                authorSpan.className = 'author';
                authorSpan.textContent = `by ${dict.author}`;

                infoDiv.appendChild(nameSpan);
                infoDiv.appendChild(authorSpan);
                
                const buttonDiv = document.createElement('div');
                
                const selectBtn = document.createElement('button');
                selectBtn.textContent = 'Select';
                selectBtn.className = 'dict-btn select';
                selectBtn.disabled = index === activeDictionaryIndex;
                selectBtn.onclick = () => {
                    activeDictionaryIndex = index;
                    saveAllDictionaries();
                    updateActiveDictDisplay();
                    populateDictionaryManager();
                    showNotification(`"${dict.name}" is now the active dictionary.`);
                };

                const exportBtn = document.createElement('button');
                exportBtn.textContent = 'Export';
                exportBtn.className = 'dict-btn';
                exportBtn.onclick = () => handleExportClick(index);

                const editBtn = document.createElement('button');
                editBtn.textContent = 'Edit';
                editBtn.className = 'dict-btn';
                editBtn.onclick = () => openWordEditor(index);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.className = 'dict-btn delete';
                deleteBtn.onclick = () => {
                    if (confirm(`Are you sure you want to delete the "${dict.name}" dictionary? This cannot be undone.`)) {
                        dictionaries.splice(index, 1);
                        if (activeDictionaryIndex >= index) {
                            activeDictionaryIndex = Math.max(0, activeDictionaryIndex - 1);
                        }
                        if (dictionaries.length === 0) createNewDictionary(true); // Create a new default if all are deleted
                        saveAllDictionaries();
                        updateActiveDictDisplay();
                        populateDictionaryManager();
                    }
                };

                buttonDiv.appendChild(selectBtn);
                buttonDiv.appendChild(exportBtn);
                buttonDiv.appendChild(editBtn);
                buttonDiv.appendChild(deleteBtn);
                
                li.appendChild(infoDiv);
                li.appendChild(buttonDiv);
                dictionaryListEl.appendChild(li);
            });
        }
        
        function createNewDictionary(isDefault = false) {
            const name = isDefault ? "Default" : prompt("Enter a name for your new dictionary:");
            if (!name && !isDefault) return;

            const author = isDefault ? "System" : prompt("Enter your name (Author):");
            if (!author && !isDefault) return;

            const newDict = {
                name: name,
                author: author,
                description: isDefault ? "Default dictionary." : "",
                words: isDefault ? { ...defaultWordMap } : {}
            };
            dictionaries.push(newDict);
            activeDictionaryIndex = dictionaries.length - 1;
            saveAllDictionaries();
            updateActiveDictDisplay();
            populateDictionaryManager();
            showNotification(`Created and selected new dictionary: "${name}"`);
        }

        function openWordEditor(dictIndex) {
            wordEditorTitleEl.textContent = `Editing: ${dictionaries[dictIndex].name}`;
            wordListEl.innerHTML = '';
            
            const sortedWords = Object.keys(dictionaries[dictIndex].words).sort();
            sortedWords.forEach(word => {
                const li = document.createElement('li');
                const wordSpan = document.createElement('span');
                wordSpan.className = 'dictionary-word';
                wordSpan.textContent = word;

                const graflectSpan = document.createElement('span');
                graflectSpan.className = 'dictionary-graflect';
                graflectSpan.textContent = dictionaries[dictIndex].words[word];

                const editBtn = document.createElement('button');
                editBtn.className = 'dict-btn edit';
                editBtn.textContent = 'Edit';
                
                const removeBtn = document.createElement('button');
                removeBtn.className = 'dict-btn remove';
                removeBtn.textContent = 'Remove';
                
                const textDiv = document.createElement('div');
                textDiv.style.display = 'flex';
                textDiv.style.gap = '1em';
                textDiv.style.alignItems = 'center';
                textDiv.appendChild(wordSpan);
                textDiv.appendChild(graflectSpan);

                const buttonDiv = document.createElement('div');
                buttonDiv.appendChild(editBtn);
                buttonDiv.appendChild(removeBtn);

                li.appendChild(textDiv);
                li.appendChild(buttonDiv);
                wordListEl.appendChild(li);

                removeBtn.onclick = () => {
                    delete dictionaries[dictIndex].words[word];
                    saveAllDictionaries();
                    li.remove();
                    showNotification(`'${word}' removed.`);
                };

                editBtn.onclick = () => {
                    textDiv.innerHTML = '';
                    const wordLabel = document.createElement('span');
                    wordLabel.className = 'dictionary-word';
                    wordLabel.textContent = word;

                    const editInput = document.createElement('input');
                    editInput.type = 'text';
                    editInput.className = 'dict-edit-input';
                    editInput.value = dictionaries[dictIndex].words[word];
                    
                    textDiv.appendChild(wordLabel);
                    textDiv.appendChild(editInput);
                    editInput.focus();

                    buttonDiv.innerHTML = '';
                    const saveBtn = document.createElement('button');
                    saveBtn.className = 'dict-btn save';
                    saveBtn.textContent = 'Save';
                    
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'dict-btn';
                    cancelBtn.textContent = 'Cancel';

                    buttonDiv.appendChild(saveBtn);
                    buttonDiv.appendChild(cancelBtn);

                    saveBtn.onclick = () => {
                        dictionaries[dictIndex].words[word] = editInput.value;
                        saveAllDictionaries();
                        openWordEditor(dictIndex); // Refresh list
                        showNotification(`'${word}' updated.`);
                    };
                    cancelBtn.onclick = () => {
                        openWordEditor(dictIndex); // Refresh list
                    };
                };
            });

            dictionaryManagerModal.style.display = 'none';
            wordEditorModal.style.display = 'flex';
        }

        // --- EVENT LISTENERS ---
        transliterateBtn.addEventListener('click', handleTransliterateClick);
        diagnosticBtn.addEventListener('click', handleDiagnosticClick);
        manageDictBtn.addEventListener('click', openDictionaryManager);
        newDictBtn.addEventListener('click', () => createNewDictionary(false));
        importInput.addEventListener('change', handleImportChange);

        closeModalManagerBtn.addEventListener('click', () => dictionaryManagerModal.style.display = 'none');
        closeWordEditorBtn.addEventListener('click', () => {
            wordEditorModal.style.display = 'none';
            openDictionaryManager(); // Go back to manager
        });
        window.addEventListener('click', (event) => {
            if (event.target == dictionaryManagerModal) dictionaryManagerModal.style.display = 'none';
            if (event.target == wordEditorModal) {
                 wordEditorModal.style.display = 'none';
                 openDictionaryManager();
            }
        });
        
        // --- INITIALIZATION ---
        loadDictionaries();
    </script>
</body>
</html>
