<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multi-Lingual RSS Feed Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 900px;
            margin: 20px auto;
            padding: 0 15px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            border-bottom: 1px solid #eaeaea;
            padding-bottom: 5px;
        }
        code {
            background-color: #eee;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .folder-select {
            border: 2px dashed #ccc;
            padding: 15px;
            text-align: center;
            border-radius: 8px;
        }
        .folder-select-label {
            display: block;
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        .folder-select-label:hover {
            background-color: #0056b3;
        }
        input[type="file"] {
            display: none;
        }
        .status {
            font-style: italic;
            color: #555;
            margin-top: 10px;
            height: 20px;
        }
        .output-container {
            margin-top: 20px;
        }
        .output-box {
            margin-bottom: 25px;
        }
        textarea {
            width: 100%;
            min-height: 250px;
            border-radius: 4px;
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
            font-family: monospace;
            white-space: pre;
            overflow-wrap: normal;
            overflow-x: scroll;
        }
        .copy-button {
            display: inline-block;
            padding: 8px 15px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: background-color 0.2s;
        }
        .copy-button:hover {
            background-color: #218838;
        }
        #log {
            margin-top: 15px;
            background-color: #f8f9fa;
            border: 1px solid #eee;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9em;
            max-height: 150px;
            overflow-y: auto;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>Multi-Lingual RSS Feed Generator</h1>
        <p>This tool generates parallel RSS feeds for each language defined in your localization files.</p>
        
        <h2>1. Select Project Folders</h2>
        <div class="input-grid">
            <div class="folder-select">
                <h3>Blog Posts</h3>
                <p>Select your root <code>/blog</code> folder.</p>
                <label class="folder-select-label" for="blogInput">Select /blog Folder</label>
                <input type="file" id="blogInput" webkitdirectory directory multiple>
                <div class="status" id="blogStatus">Not selected</div>
            </div>
            <div class="folder-select">
                <h3>Localization Files</h3>
                <p>Select your root <code>/localization</code> folder.</p>
                <label class="folder-select-label" for="localizationInput">Select /localization Folder</label>
                <input type="file" id="localizationInput" webkitdirectory directory multiple>
                <div class="status" id="localizationStatus">Not selected</div>
            </div>
        </div>

        <h2>2. Generated Feeds</h2>
        <p>A separate feed will be generated for each language. Save each as <code>rss_{lang}.xml</code> in your project root.</p>
        <div id="outputContainer"></div>
        
        <h3>Processing Log</h3>
        <div id="log">Awaiting folder selection...</div>
    </div>

    <script>
        // --- Global State ---
        let blogFiles = null;
        let localizationData = null;

        // --- Event Listeners ---
        document.getElementById('blogInput').addEventListener('change', handleBlogSelect);
        document.getElementById('localizationInput').addEventListener('change', handleLocalizationSelect);

        // --- File Handlers ---
        async function handleBlogSelect(event) {
            blogFiles = event.target.files;
            const statusEl = document.getElementById('blogStatus');
            if (blogFiles.length > 0) {
                statusEl.textContent = `${blogFiles.length} files selected.`;
                statusEl.style.color = 'green';
            } else {
                statusEl.textContent = 'Not selected';
                statusEl.style.color = '#555';
            }
            await tryStartGenerator();
        }

        async function handleLocalizationSelect(event) {
            const files = event.target.files;
            const statusEl = document.getElementById('localizationStatus');
            if (files.length === 0) {
                localizationData = null;
                statusEl.textContent = 'Not selected';
                statusEl.style.color = '#555';
                return;
            }
            
            localizationData = {};
            const jsonPromises = [];
            for (const file of files) {
                if (file.name.endsWith('.json')) {
                    const fileNameKey = file.name.replace('.json', '');
                    jsonPromises.push(
                        file.text().then(text => {
                            try {
                                localizationData[fileNameKey] = JSON.parse(text);
                                logMessage(`[OK] Loaded localization file: ${file.name}`);
                            } catch (e) {
                                logMessage(`[ERROR] Failed to parse ${file.name}: ${e.message}`);
                            }
                        })
                    );
                }
            }
            await Promise.all(jsonPromises);

            const loadedCount = Object.keys(localizationData).length;
            if (loadedCount > 0) {
                statusEl.textContent = `${loadedCount} file(s) loaded.`;
                statusEl.style.color = 'green';
            } else {
                statusEl.textContent = 'No valid JSON found.';
                statusEl.style.color = 'red';
            }
            await tryStartGenerator();
        }

        // --- Core Logic ---
        async function tryStartGenerator() {
            if (blogFiles && localizationData) {
                logMessage("--- Starting RSS Feed Generation ---");
                await generateFeeds();
            }
        }
        
        async function generateFeeds() {
            const outputContainer = document.getElementById('outputContainer');
            outputContainer.innerHTML = ''; // Clear previous results
            
            // 1. Process all blog files to extract metadata and DOM
            const processedPosts = [];
            for (const file of blogFiles) {
                if (file.name.endsWith('.html')) {
                    const postData = await processBlogFile(file);
                    if (postData) {
                        processedPosts.push(postData);
                    }
                }
            }
            logMessage(`Processed ${processedPosts.length} valid blog posts.`);

            // 2. Get all unique language codes from all translation files
            const allLanguages = new Set();
            Object.values(localizationData).forEach(fileContent => {
                Object.keys(fileContent).forEach(langCode => allLanguages.add(langCode));
            });
            logMessage(`Found languages: ${Array.from(allLanguages).join(', ')}`);


            // 3. For each language, create a translated feed
            for (const langCode of allLanguages) {
                 // Helper function to find a global key across all loaded translation files
                const getGlobalTranslation = (key, fallback) => {
                    for (const sourceName in localizationData) {
                        if (localizationData[sourceName][langCode] && localizationData[sourceName][langCode][key]) {
                            return localizationData[sourceName][langCode][key];
                        }
                    }
                    return fallback;
                };
                
                const channelTitle = getGlobalTranslation('site_title', `Pelmeniboiler (${langCode.toUpperCase()})`);
                const channelDescription = getGlobalTranslation('site_description', 'Neat stuff I like.');

                const channel = {
                    title: channelTitle,
                    description: channelDescription,
                    link: "https://pelmeniboiler.github.io/",
                    language: langCode,
                    lastBuildDate: new Date().toUTCString(),
                    generator: 'Multi-Lingual RSS Generator'
                };

                const translatedItems = [];
                for (const post of processedPosts) {
                    const translatedArticle = translateArticle(post, langCode);
                    if (translatedArticle) {
                        translatedItems.push({
                            title: translatedArticle.title,
                            link: post.link,
                            description: translatedArticle.description,
                            pubDate: post.pubDate,
                            guid: post.link,
                        });
                    }
                }

                if (translatedItems.length > 0) {
                    // Sort items by date, newest first
                    translatedItems.sort((a, b) => new Date(b.pubDate) - new Date(a.pubDate));
                    const rssFeed = buildRssFeed(channel, translatedItems);
                    createOutputBox(langCode, rssFeed);
                }
            }
        }
        
        function processBlogFile(file) {
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => {
                    const content = e.target.result;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(content, 'text/html');

                    const pubDateEl = doc.querySelector('meta[name="pubDate"]');
                    const translationSourceEl = doc.querySelector('meta[name="translation-source"]');

                    if (!translationSourceEl) {
                        logMessage(`[WARNING] Skipping ${file.name}: Missing <meta name="translation-source">.`);
                        resolve(null);
                        return;
                    }

                    const siteUrl = "https://pelmeniboiler.github.io/";
                    const cleanSiteUrl = siteUrl.endsWith('/') ? siteUrl : siteUrl + '/';
                    const link = `${cleanSiteUrl}blog/${file.name}`;
                    const pubDate = pubDateEl ? new Date(pubDateEl.getAttribute('content')).toUTCString() : new Date().toUTCString();
                    
                    resolve({
                        link,
                        pubDate,
                        translationSource: translationSourceEl.getAttribute('content'),
                        dom: doc,
                    });
                };
                reader.onerror = () => {
                    logMessage(`[ERROR] Could not read file: ${file.name}`);
                    resolve(null);
                };
                reader.readAsText(file);
            });
        }

        function translateArticle(post, langCode) {
            const translationTable = localizationData[post.translationSource]?.[langCode];
            if (!translationTable) {
                // This is normal if a translation doesn't exist for a specific article, so we don't log it.
                return null;
            }

            // Create a deep copy of the document to avoid modifying the original
            const translatedDoc = post.dom.cloneNode(true);

            // Translate all elements with data-key
            translatedDoc.querySelectorAll('[data-key]').forEach(el => {
                const key = el.dataset.key;
                if (translationTable[key]) {
                    el.innerHTML = translationTable[key];
                }
            });

            const title = translatedDoc.querySelector('title')?.textContent || 'Untitled';
            const description = translatedDoc.querySelector('article.content')?.innerHTML || 'No content found.';

            return { title, description };
        }

        // --- XML and UI Builders ---
        function buildRssFeed(channel, items) {
            const itemXml = items.map(item => `
        <item>
            <title>${escapeXml(item.title)}</title>
            <link>${item.link}</link>
            <description><![CDATA[${item.description}]]></description>
            <pubDate>${item.pubDate}</pubDate>
            <guid isPermaLink="true">${item.guid}</guid>
        </item>`).join('');

            return `<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
    <title>${escapeXml(channel.title)}</title>
    <link>${channel.link}</link>
    <description>${escapeXml(channel.description)}</description>
    <language>${channel.language}</language>
    <generator>${channel.generator}</generator>
    <lastBuildDate>${channel.lastBuildDate}</lastBuildDate>
    <atom:link href="${channel.link}rss_${channel.language}.xml" rel="self" type="application/rss+xml" />${itemXml}
</channel>
</rss>`;
        }
        
        function createOutputBox(langCode, rssFeed) {
            const container = document.getElementById('outputContainer');
            const id = `rssOutput_${langCode}`;

            const box = document.createElement('div');
            box.className = 'output-box';
            
            box.innerHTML = `
                <h3>Feed: ${langCode.toUpperCase()} (Save as <code>rss_${langCode}.xml</code>)</h3>
                <textarea id="${id}" readonly></textarea>
                <button class="copy-button" data-target-id="${id}">Copy to Clipboard</button>
            `;
            
            container.appendChild(box);
            document.getElementById(id).value = rssFeed; // Set value after appending

            box.querySelector('.copy-button').addEventListener('click', (e) => {
                const targetId = e.target.dataset.targetId;
                copyToClipboard(targetId);
            });
        }
        
        function copyToClipboard(elementId) {
            const textarea = document.getElementById(elementId);
            if (!textarea || !textarea.value) {
                alert('Nothing to copy!');
                return;
            }
            navigator.clipboard.writeText(textarea.value).then(() => {
                alert(`Feed for '${elementId.split('_')[1]}' copied to clipboard!`);
            }).catch(err => {
                alert('Failed to copy text.');
                console.error('Copy failed', err);
            });
        }
        
        // --- Utilities ---
        function escapeXml(unsafe) {
            return unsafe.replace(/[<>&'"]/g, c => ({'<':'&lt;','>':'&gt;','&':'&amp;','\'':'&apos;','"':'&quot;'}[c]));
        }

        function logMessage(message) {
            const log = document.getElementById('log');
            log.innerHTML += `<div>${escapeXml(message)}</div>`;
            log.scrollTop = log.scrollHeight; // Auto-scroll
        }
    </script>
</body>
</html>
