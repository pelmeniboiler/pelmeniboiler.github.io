/**
 * /scripts/blog/demos/filtertakeout.js
 * Contains the JavaScript logic for the X Quality Filter script generator module.
 * This script is loaded on pages that include the generator module.
 * The main logic is wrapped in initializeFilterTakeout, which is called
 * by an event listener once the module's HTML is loaded.
 */
function initializeFilterTakeout() {
    // Find the generator module on the page. If it's not there, do nothing.
    const filterModule = document.getElementById('filter-takeout-module');
    if (!filterModule) {
        return;
    }
    console.log("Filter Takeout module initializing...");

    // --- DATA ---
    const EMOJI_SETS = {
        faces: genRange(0x1F600, 0x1F64F).concat(genRange(0x1F910, 0x1F92F)).concat(genRange(0x1F970, 0x1F97F)),
        symbols: genRange(0x1F300, 0x1F5FF),
        political: ['🇵🇸', '🏳️‍⚧️', '🔻', '🍉', '🌻', '☭', '🌹', '✊', '🇷🇺', '🇺🇦', '🇮🇱', '🏳️‍🌈', '🌽', '🌾', '⚖️', '🌐', '🤝'],
        religious: ['🇻🇦', '✝️', '☦️', '☪️', '✡️', '🕉️', '☸️', '🔯', '🕎', '☯️'],
        edgy: ['💀', '🔪', '🩸', '⛓️', '⚰️', '💣', '🔫', '🔥', '😈', '👿', '👹', '👺', '☠️'],
        slop: ['🤡', '💩', '😂', '🤣', '🤪', '💯', '🙏', '👇', '👉', '👀', '🍿'],
        finance: ['🚀', '📈', '📉', '💰', '💸', '🤑', '💎', '🙌', '₿'],
        events: ['💉', '🦠', '😷', '☢️', '☣️'],
        flags: genFlags()
    };

    const BASE_SCRIPT = `
// ==UserScript==
// @name         X Quality Filter (Custom)
// @namespace    http://tampermonkey.net/
// @version      1.8-Custom
// @description  Scans 'X the everything app' timeline for users with specific emojis in their name, attempts to block them, and hides the tweet. Generated by customizer.
// @author       pelmeniboiler (customized by you)
// @match        https://twitter.com/*
// @match        https://x.com/*
// @grant        none
// @run-at       document-idle
// ==/UserScript==

(function() {
    'use strict';

    // --- CONFIGURATION ---
    // EMOJI_LIST_PLACEHOLDER
    const CLICK_DELAY_MS = 800;

    // --- SCRIPT STATE ---
    const processedTweets = new Set();

    // --- UTILITY FUNCTIONS ---
    function log(message, ...args) {
        console.log(\`[XQF-Custom] \${message}\`, ...args);
    }

    function delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function simulateClick(element) {
        if (!element) {
            log("Error: Tried to click a null/undefined element.");
            return false;
        }
        log("Simulating click on:", element);
        if (element.offsetParent === null && element.isConnected) {
            log("Warning: Element might not be visible or interactable, but attempting click anyway.", element);
        }
        element.click();
        await delay(CLICK_DELAY_MS);
        return true;
    }

    function getUserInfo(tweetElement) {
        let displayName = "Unknown Display Name";
        let userHandle = "Unknown Handle";
        const userNameContainer = tweetElement.querySelector('div[data-testid="User-Name"]');

        if (userNameContainer) {
            const userLinks = Array.from(userNameContainer.querySelectorAll('a[href^="/"][role="link"]'));
            let mainUserLink = null;
            for (const link of userLinks) {
                const href = link.getAttribute('href');
                if (href && href.split('/').length === 2 && !href.includes('/status/')) {
                    if (link.querySelector('span')) { mainUserLink = link; break; }
                }
            }
            if (!mainUserLink && userLinks.length > 0) {
                 for (const link of userLinks) {
                    const href = link.getAttribute('href');
                     if (href && !href.includes('/status/')) { mainUserLink = link; break; }
                 }
            }

            if (mainUserLink) {
                const spansInLink = mainUserLink.querySelectorAll('span');
                let collectedDisplayNameParts = [];
                spansInLink.forEach(span => {
                    const text = span.innerText.trim();
                    if (text) {
                        if (text.startsWith('@')) {
                            if (userHandle === "Unknown Handle") userHandle = text;
                        } else {
                            if (text.toLowerCase() !== 'verified' && !/^\\d+(s|m|h|d|mo|yr)$/.test(text) && text !== '·') {
                                collectedDisplayNameParts.push(text);
                            }
                        }
                    }
                });
                if (collectedDisplayNameParts.length > 0) displayName = collectedDisplayNameParts.join(' ');
            }

            if (userHandle === "Unknown Handle") {
                const handleCandidates = userNameContainer.querySelectorAll('div[dir="ltr"] > span, span');
                for (const candidate of handleCandidates) {
                    if (candidate.innerText && candidate.innerText.startsWith('@')) {
                        userHandle = candidate.innerText.trim(); break;
                    }
                }
            }
            if (displayName === "Unknown Display Name" && userHandle !== "Unknown Handle") {
                 const allSpans = userNameContainer.querySelectorAll('span');
                 for (const span of allSpans) {
                    const text = span.innerText.trim();
                    if (text && text !== userHandle && !text.startsWith('@') && text.toLowerCase() !== 'verified' && span.offsetParent !== null) {
                        displayName = text; break;
                    }
                 }
            }
        } else {
            const links = tweetElement.querySelectorAll('a[href^="/"]');
            for (const link of links) {
                const text = link.innerText.trim();
                if (text.startsWith('@') && userHandle === "Unknown Handle") userHandle = text;
                else if (text.length > 0 && !text.startsWith('@') && displayName === "Unknown Display Name" && link.offsetParent !== null) {
                     if(link.href && link.href.split('/').length <= 4 && !link.href.includes('/status/')) {
                        displayName = text.split('\\n')[0];
                     }
                }
                if (displayName !== "Unknown Display Name" && userHandle !== "Unknown Handle") break;
            }
        }

        if (displayName !== "Unknown Display Name" && userHandle !== "Unknown Handle" && displayName.includes(userHandle)) {
            displayName = displayName.replace(userHandle, "").trim();
        }
        if (displayName.trim() === "") displayName = "Unknown Display Name";
        return { displayName: displayName.replace(/\\s+/g, ' ').trim(), userHandle };
    }

    // CONTAINS_EMOJI_FUNCTION_PLACEHOLDER

    async function attemptBlockUser(tweetElement) {
        const userInfo = getUserInfo(tweetElement);
        let tweetIdForLog = "unknown_tweet_id";
        const statusLinks = tweetElement.querySelectorAll('a[href*="/status/"]');
        for (const link of statusLinks) {
            const href = link.getAttribute('href');
            const match = href.match(/\\/status\\/(\\d+)/);
            if (match && match[1]) { tweetIdForLog = match[1]; break; }
        }
        if (tweetIdForLog === "unknown_tweet_id") {
            tweetIdForLog = (tweetElement.innerText || "no_text").slice(0,70).replace(/\\n/g, ' ');
        }

        const actionKey = \`blockAttempt_\${tweetIdForLog}_\${userInfo.userHandle}_\${tweetElement.outerHTML.slice(0,50)}\`;
        if (processedTweets.has(actionKey)) return;

        log(\`Processing tweet (ID: \${tweetIdForLog}, User: \${userInfo.displayName} (\${userInfo.userHandle})) for potential block.\`);

        const moreButton = tweetElement.querySelector('button[data-testid="caret"][aria-label="More"], button[data-testid="caret"], div[data-testid="caret"], div[aria-label="More"], div[aria-label^="More options"]');
        if (!moreButton) {
            log(\`Could not find 'More' button for tweet (ID: \${tweetIdForLog}, User: \${userInfo.displayName} (\${userInfo.userHandle})).\`);
            processedTweets.add(actionKey); return;
        }
        log(\`Found 'More' button for User: \${userInfo.displayName} (\${userInfo.userHandle}). Clicking...\`, moreButton);
        if (!await simulateClick(moreButton)) {
            log(\`Failed to click 'More' button for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
            processedTweets.add(actionKey); return;
        }

        let blockMenuItem = null;
        const menuItems = Array.from(document.querySelectorAll('div[role="menuitem"], [data-testid="Dropdown"] div[role="button"], [data-testid="Dropdown"] div[role="link"]'));
        log(\`Searching for 'Block' menu item for User: \${userInfo.displayName} (\${userInfo.userHandle}). Found \${menuItems.length} items.\`, menuItems.map(mi => mi.textContent.trim().slice(0,100)));

        for (const item of menuItems) {
            const itemText = (item.textContent || "").toLowerCase();
            const spanInside = item.querySelector('span');
            const spanText = (spanInside ? (spanInside.textContent || "") : "").toLowerCase();
            const blockTextToMatch = \`block \${userInfo.userHandle}\`.toLowerCase();
            const genericBlockText = "block ";

            if (itemText.includes(blockTextToMatch) || spanText.includes(blockTextToMatch) ||
                (itemText.startsWith(genericBlockText) && itemText.length < (genericBlockText.length + userInfo.userHandle.length + 10)) ||
                (spanText.startsWith(genericBlockText) && spanText.length < (genericBlockText.length + userInfo.userHandle.length + 10)) ) {
                if (!itemText.includes('unblock') && !spanText.includes('unblock')) {
                    blockMenuItem = item;
                    log(\`Potential 'Block' menu item found: "\${item.textContent.trim()}" for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
                    break;
                } else {
                    log(\`Skipping 'Unblock' item: "\${item.textContent.trim()}"\`);
                }
            }
        }

        if (!blockMenuItem) {
            log(\`Could not find 'Block \${userInfo.userHandle}' menu item. User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
            const firstMenuItem = menuItems[0];
            if (firstMenuItem && firstMenuItem.offsetParent !== null) {
                 log("Attempting to close dropdown by clicking body.");
                 document.body.click(); await delay(200);
            }
            processedTweets.add(actionKey); return;
        }
        log(\`Found 'Block \${userInfo.userHandle}' menu item. Clicking...\`, blockMenuItem);
        if (!await simulateClick(blockMenuItem)) {
            log(\`Failed to click 'Block \${userInfo.userHandle}' menu item.\`);
            processedTweets.add(actionKey); return;
        }

        let confirmButton = null;
        const allButtons = Array.from(document.querySelectorAll('button[data-testid="confirmationSheetConfirm"], button'));
        for (const btn of allButtons) {
            if (btn.getAttribute('data-testid') === 'confirmationSheetConfirm') {
                if ((btn.textContent || "").toLowerCase().includes('block')) { confirmButton = btn; break; }
            }
            if (!confirmButton && (btn.textContent || "").trim().toLowerCase() === 'block' && btn.offsetParent !== null) {
                 log("Found button with text 'Block', considering as confirmation.", btn);
                 confirmButton = btn; break;
            }
        }

        if (!confirmButton) {
            log(\`Could not find 'Block' confirmation button for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
            processedTweets.add(actionKey); return;
        }
        log(\`Found 'Block' confirmation button for User: \${userInfo.displayName} (\${userInfo.userHandle}). Clicking...\`, confirmButton);
        if (!await simulateClick(confirmButton)) {
            log(\`Failed to click 'Block' confirmation button for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
            processedTweets.add(actionKey); return;
        }

        log(\`Block sequence successfully completed for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
        processedTweets.add(actionKey);

        log("Attempting to hide tweet from view for User: " + userInfo.displayName, tweetElement);
        tweetElement.style.transition = 'opacity 0.5s ease-out, max-height 0.5s ease-out, margin 0.5s ease-out, padding 0.5s ease-out';
        tweetElement.style.opacity = '0';
        tweetElement.style.maxHeight = '0px';
        tweetElement.style.overflow = 'hidden';
        tweetElement.style.margin = '0px';
        tweetElement.style.padding = '0px';
        tweetElement.style.border = 'none';
        await delay(500);
        log("Tweet for User: " + userInfo.displayName + " should now be hidden.");
    }


    async function processTweetElement(tweetElement) {
        const userInfo = getUserInfo(tweetElement);
        const scanKey = \`scanned_\${userInfo.userHandle}_\${(tweetElement.querySelector('a[href*="/status/"]')?.getAttribute('href') || tweetElement.innerText.slice(0,30))}\`;
        if (processedTweets.has(scanKey)) return;

        if (containsBannedEmoji(tweetElement)) {
            await attemptBlockUser(tweetElement);
        }
        processedTweets.add(scanKey);
    }

    function handleMutations(mutationsList, observer) {
        for (const mutation of mutationsList) {
            if (mutation.type === 'childList') {
                mutation.addedNodes.forEach(node => {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        if (node.matches && (node.matches('article') || node.matches('[data-testid="tweet"]'))) {
                            processTweetElement(node);
                        }
                        const newTweetsInNode = node.querySelectorAll('article, [data-testid="tweet"]');
                        newTweetsInNode.forEach(tweet => processTweetElement(tweet));
                    }
                });
            }
        }
    }

    function observeTimeline() {
        log("Attempting to start MutationObserver to monitor timeline...");
        const targetNode = document.querySelector('main') || document.body;
        if (!targetNode) {
            log("Error: Could not find targetNode (main or body) for MutationObserver."); return;
        }
        log("Target node for observer:", targetNode);
        const config = { childList: true, subtree: true };
        const observer = new MutationObserver(handleMutations);
        try {
            observer.observe(targetNode, config);
            log("MutationObserver is now active and observing.", targetNode);
            document.body.classList.add('emoji-blocker-observer-active');
        } catch (e) { log("Error starting MutationObserver:", e); return; }

        log("Performing initial scan of existing tweets...");
        const initialTweets = document.querySelectorAll('article, [data-testid="tweet"]');
        log(\`Initial scan found \${initialTweets.length} potential tweet elements.\`);
        initialTweets.forEach(tweet => processTweetElement(tweet));
        log("Initial scan complete.");
    }

    log("Twitter Emoji User Blocker script started.");
    if (typeof BANNED_EMOJIS !== 'undefined') {
        log("Banned Emojis Count:", BANNED_EMOJIS.length);
    }

    function robustStart() {
        if (document.body && (document.body.scrollHeight > 0 || document.querySelector('main'))) {
            log(\`Document seems ready enough (state: \${document.readyState}). Calling observeTimeline.\`);
            observeTimeline();
        } else {
            log(\`Document not ready enough (state: \${document.readyState}). Retrying in 500ms.\`);
            setTimeout(robustStart, 500);
        }
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
        robustStart();
    } else {
        document.addEventListener('DOMContentLoaded', () => { log("DOMContentLoaded event fired."); robustStart(); });
        window.addEventListener('load', () => {
            log("Window 'load' event fired.");
            if (!document.body.classList.contains('emoji-blocker-observer-active')) {
                log("Observer not yet active, attempting robustStart from window.load.");
                robustStart();
            }
        });
    }
})();
        `;

    const CONTAINS_EMOJI_FUNCTION_SPECIFIC = `
    function containsBannedEmoji(tweetElement) {
        const userInfo = getUserInfo(tweetElement);
        const userNameDiv = tweetElement.querySelector('div[data-testid="User-Name"]');

        if (userNameDiv) {
            // Check for image emojis (img alt)
            const images = userNameDiv.querySelectorAll('img[alt]');
            for (const img of images) {
                const emojiAltText = img.getAttribute('alt');
                if (emojiAltText && BANNED_EMOJIS.includes(emojiAltText)) {
                    log(\`Banned emoji (img alt) "\${emojiAltText}" for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
                    return true;
                }
            }

            // Check for text emojis
            const nameText = userNameDiv.innerText;
            for (const bannedEmoji of BANNED_EMOJIS) {
                if (nameText.includes(bannedEmoji)) {
                    log(\`Banned emoji (text) "\${bannedEmoji}" in name "\${nameText.slice(0,30)}" for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
                    return true;
                }
            }
        }
        return false;
    }`;

    const CONTAINS_EMOJI_FUNCTION_ALL = `
    function containsBannedEmoji(tweetElement) {
        const userInfo = getUserInfo(tweetElement);
        const userNameDiv = tweetElement.querySelector('div[data-testid="User-Name"]');
        // This regex is a common pattern to catch a wide range of emojis.
        const emojiRegex = new RegExp([
            '[\\\\u2700-\\\\u27bf]', // Dingbats
            '[\\\\u{1f300}-\\\\u{1f5ff}]', // Miscellaneous Symbols and Pictographs
            '[\\\\u{1f600}-\\\\u{1f64f}]', // Emoticons
            '[\\\\u{1f680}-\\\\u{1f6ff}]', // Transport and Map Symbols
            '[\\\\u{1f700}-\\\\u{1f77f}]', // Alchemical Symbols
            '[\\\\u{1f780}-\\\\u{1f7ff}]', // Geometric Shapes Extended
            '[\\\\u{1f800}-\\\\u{1f8ff}]', // Supplemental Arrows-C
            '[\\\\u{1f900}-\\\\u{1f9ff}]', // Supplemental Symbols and Pictographs
            '[\\\\u{1fa00}-\\\\u{1fa6f}]', // Chess Symbols
            '[\\\\u{1fa70}-\\\\u{1faff}]'  // Symbols and Pictographs Extended-A
        ].join('|'), 'u');


        if (userNameDiv) {
            // Check for image emojis (any img with an alt attribute is likely an emoji)
            const images = userNameDiv.querySelectorAll('img[alt]');
            if (images.length > 0) {
                 for (const img of images) {
                    const altText = img.getAttribute('alt');
                    if (altText && altText.length < 5) {
                         log(\`Banned any emoji (img alt: "\${altText}") for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
                         return true;
                    }
                 }
            }

            // Check for text emojis using the regex
            if (emojiRegex.test(userNameDiv.innerText)) {
                log(\`Banned any emoji (text) for User: \${userInfo.displayName} (\${userInfo.userHandle}).\`);
                return true;
            }
        }
        return false;
    }`;

    // --- HELPERS ---
    function genRange(start, end) {
        return Array.from({ length: end - start + 1 }, (_, i) => String.fromCodePoint(start + i));
    }
    
    function genFlags() {
        const flags = [];
        const base = 0x1F1E6; // Regional Indicator Symbol Letter A
        for (let i = 0; i < 26; i++) {
            for (let j = 0; j < 26; j++) {
                flags.push(String.fromCodePoint(base + i) + String.fromCodePoint(base + j));
            }
        }
        return flags;
    }

    // --- DOM ELEMENTS (scoped to the module) ---
    const generateBtn = filterModule.querySelector('#generate-btn');
    const outputContainer = filterModule.querySelector('#output-container');
    const outputScriptEl = filterModule.querySelector('#output-script');
    const copyBtn = filterModule.querySelector('#copy-btn');
    const copyFeedback = filterModule.querySelector('#copy-feedback');
    const allCheckboxes = filterModule.querySelectorAll('#categories input[type="checkbox"]');
    const customEmojisTextarea = filterModule.querySelector('#custom-emojis');
    const livePreviewBox = filterModule.querySelector('#live-preview-box');
    const previewCountEl = filterModule.querySelector('#preview-count');

    // --- FUNCTIONS ---
    function populateCategoryPreviews() {
        for (const key in EMOJI_SETS) {
            const previewEl = filterModule.querySelector(`#preview-${key}`);
            if (previewEl) {
                const sample = EMOJI_SETS[key].slice(0, 15).join(' ');
                const moreCount = EMOJI_SETS[key].length - 15;
                previewEl.textContent = sample + (moreCount > 0 ? ` ...and ${moreCount} more` : '');
            }
        }
    }
    
    function updateLivePreview() {
        const bannedEmojis = new Set();
        const blockAll = filterModule.querySelector('#cat-all').checked;

        if (blockAll) {
            livePreviewBox.innerHTML = '<span class="text-gray-600 font-medium">Blocking ALL emojis.</span>';
            previewCountEl.textContent = '';
            return;
        }

        filterModule.querySelectorAll('.category-checkbox:checked').forEach(cb => {
            const category = cb.id.replace('cat-', '');
            if (EMOJI_SETS[category]) {
                EMOJI_SETS[category].forEach(e => bannedEmojis.add(e));
            }
        });

        const customInput = customEmojisTextarea.value;
        const customEmojis = customInput.match(/\p{Emoji_Presentation}/gu) || [];
        customEmojis.forEach(e => bannedEmojis.add(e));

        const emojiArray = Array.from(bannedEmojis);
        if (emojiArray.length === 0) {
            livePreviewBox.innerHTML = '<span class="text-gray-400 text-sm">Your selected emojis will appear here...</span>';
            previewCountEl.textContent = '';
        } else {
            livePreviewBox.textContent = emojiArray.join(' ');
            previewCountEl.textContent = `${emojiArray.length} unique emojis selected.`;
        }
    }

    function handleSelectAllChange(e) {
        const isChecked = e.target.checked;
        const otherCheckboxes = filterModule.querySelectorAll('.category-checkbox');
        
        otherCheckboxes.forEach(cb => {
            cb.disabled = isChecked;
            if (isChecked) {
                cb.checked = false;
                cb.closest('.flex-col').classList.add('opacity-50', 'cursor-not-allowed');
            } else {
                cb.closest('.flex-col').classList.remove('opacity-50', 'cursor-not-allowed');
            }
        });
        
        customEmojisTextarea.disabled = isChecked;
         if (isChecked) {
            customEmojisTextarea.value = '';
            customEmojisTextarea.parentElement.classList.add('opacity-50');
        } else {
            customEmojisTextarea.parentElement.classList.remove('opacity-50');
        }
        updateLivePreview();
    }

    // --- EVENT LISTENERS ---
    generateBtn.addEventListener('click', () => {
        let finalScript;
        const blockAll = filterModule.querySelector('#cat-all').checked;

        if (blockAll) {
            finalScript = BASE_SCRIPT
                .replace('// EMOJI_LIST_PLACEHOLDER', `/* Blocking all emojis mode enabled */`)
                .replace('// CONTAINS_EMOJI_FUNCTION_PLACEHOLDER', CONTAINS_EMOJI_FUNCTION_ALL);
        } else {
            const bannedEmojis = new Set();
            filterModule.querySelectorAll('.category-checkbox:checked').forEach(cb => {
                const category = cb.id.replace('cat-', '');
                if (EMOJI_SETS[category]) EMOJI_SETS[category].forEach(e => bannedEmojis.add(e));
            });
            const customInput = customEmojisTextarea.value;
            const customEmojis = customInput.match(/\p{Emoji_Presentation}/gu) || [];
            customEmojis.forEach(e => bannedEmojis.add(e));
            
            const emojiArrayString = JSON.stringify(Array.from(bannedEmojis));
            const emojiConstString = `const BANNED_EMOJIS = ${emojiArrayString};`;
            
            finalScript = BASE_SCRIPT
                .replace('// EMOJI_LIST_PLACEHOLDER', emojiConstString)
                .replace('// CONTAINS_EMOJI_FUNCTION_PLACEHOLDER', CONTAINS_EMOJI_FUNCTION_SPECIFIC);
        }

        outputScriptEl.value = finalScript.trim();
        outputContainer.classList.remove('hidden');
    });

    copyBtn.addEventListener('click', () => {
        outputScriptEl.select();
        document.execCommand('copy');

        copyFeedback.classList.remove('opacity-0');
        setTimeout(() => {
            copyFeedback.classList.add('opacity-0');
        }, 2000);
    });

    filterModule.querySelector('#cat-all').addEventListener('change', handleSelectAllChange);
    allCheckboxes.forEach(cb => cb.addEventListener('change', updateLivePreview));
    customEmojisTextarea.addEventListener('input', updateLivePreview);

    // --- INITIALIZATION ---
    populateCategoryPreviews();
    updateLivePreview();
    console.log("Filter Takeout module initialized successfully.");
}

// This event listener ensures that the script only runs after the module
// loader has finished injecting the HTML content into the page.
document.addEventListener('modulesLoaded', initializeFilterTakeout);
